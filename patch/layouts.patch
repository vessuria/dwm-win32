diff --git a/config.def.h b/config.def.h
index 3dd90d1..fcd9583 100644
--- a/config.def.h
+++ b/config.def.h
@@ -53,6 +53,11 @@ static Layout layouts[] = {
     { L"[]=",      tile },    /* first entry is default */
     { L"><>",      NULL },    /* no layout function means floating behavior */
     { L"[M]",      monocle },
+    { L"TTT",      bstack },
+    { L"###",      gaplessgrid },
+    { L"+++",      grid },
+    { L"(@)",      spiral },
+    { L"[\\]",     dwindle },
 };
 
 /* key definitions */
@@ -94,6 +99,11 @@ static Key keys[] = {
     { MODKEY,                       'T',            setlayout,           {.v = &layouts[0]} },
     { MODKEY,                       'F',            setlayout,           {.v = &layouts[1]} },
     { MODKEY,                       'M',            setlayout,           {.v = &layouts[2]} },
+    { MODKEY,                       'B',            setlayout,           {.v = &layouts[3]} },
+    { MODKEY,                       'G',            setlayout,           {.v = &layouts[4]} },
+    { MODKEY | MOD_SHIFT,           'G',            setlayout,           {.v = &layouts[5]} },
+    { MODKEY,                       'D',            setlayout,           {.v = &layouts[6]} },
+    { MODKEY | MOD_SHIFT,           'D',            setlayout,           {.v = &layouts[7]} },
     { MODKEY|MOD_CONTROL,           VK_SPACE,       setlayout,           {0} },
     { MODKEY|MOD_SHIFT,             VK_SPACE,       togglefloating,      {0} },
     { MODKEY,                       'E',            toggleexplorer,      {0} },
diff --git a/dwm-win32.c b/dwm-win32.c
index 70ef7cd..6e5c411 100644
--- a/dwm-win32.c
+++ b/dwm-win32.c
@@ -172,6 +172,12 @@ static void grabkeys(HWND hwnd);
 static void killclient(const Arg *arg);
 static Client *manage(HWND hwnd);
 static void monocle(void);
+static void bstack(void);
+static void gaplessgrid(void);
+static void grid(void);
+static void fibonacci(int s);
+static void dwindle(void);
+static void spiral(void);
 static Client *nextchild(Client *p, Client *c);
 static Client *nexttiled(Client *c);
 static void quit(const Arg *arg);
@@ -878,6 +884,155 @@ monocle(void) {
     }
 }
 
+void
+bstack(void) {
+    int x, y, h, w, mh;
+    unsigned int i, n;
+    Client* c;
+
+    for (n = 0, c = nexttiled(clients); c; c = nexttiled(c->next))
+        if (c->mon == curmon) n++;
+    if (n == 0) return;
+
+    c = nexttiled(clients);
+    while (c && c->mon != curmon) c = nexttiled(c->next);
+    if (!c) return;
+
+    mh = mfact * curmon->wh;
+    resize(c, curmon->wx, curmon->wy,
+        curmon->ww - 2 * c->bw,
+        (n == 1 ? curmon->wh : mh) - 2 * c->bw);
+
+    if (--n == 0) return;
+
+    x = curmon->wx;
+    y = curmon->wy + mh;
+    w = curmon->ww / n;
+    h = curmon->wh - mh;
+    if (h < curmon->bh) h = curmon->wh;
+
+    for (i = 0, c = nexttiled(c->next); c; c = nexttiled(c->next)) {
+        if (c->mon != curmon) continue;
+        resize(c, x, y,
+            ((i + 1 == n) ? curmon->wx + curmon->ww - x : w) - 2 * c->bw,
+            h - 2 * c->bw);
+        if (w != curmon->ww)
+            x = c->x + WIDTH(c);
+        i++;
+    }
+}
+
+void
+gaplessgrid(void) {
+    unsigned int n, cols, rows, cn, rn, i, cx, cy, cw, ch;
+    Client* c;
+
+    for (n = 0, c = nexttiled(clients); c; c = nexttiled(c->next))
+        if (c->mon == curmon) n++;
+    if (n == 0) return;
+
+    for (cols = 0; cols <= n / 2; cols++)
+        if (cols * cols >= n) break;
+    if (n == 5) cols = 2;
+    rows = n / cols;
+
+    cw = curmon->ww / (cols ? cols : 1);
+    cn = rn = 0;
+
+    for (i = 0, c = nexttiled(clients); c; c = nexttiled(c->next)) {
+        if (c->mon != curmon) continue;
+        if (i / rows + 1 > cols - n % cols) rows = n / cols + 1;
+        ch = curmon->wh / (rows ? rows : 1);
+        cx = curmon->wx + cn * cw;
+        cy = curmon->wy + rn * ch;
+        resize(c, cx, cy, cw - 2 * c->bw, ch - 2 * c->bw);
+
+        i++;
+        rn++;
+        if (rn >= rows) { rn = 0; cn++; }
+    }
+}
+
+void
+grid(void) {
+    unsigned int i, n, cx, cy, cw, ch, aw, ah, cols, rows;
+    Client* c;
+
+    for (n = 0, c = nexttiled(clients); c; c = nexttiled(c->next))
+        if (c->mon == curmon) n++;
+    if (n == 0) return;
+
+    for (rows = 0; rows <= n / 2; rows++)
+        if (rows * rows >= n) break;
+    cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+    ch = curmon->wh / (rows ? rows : 1);
+    cw = curmon->ww / (cols ? cols : 1);
+
+    for (i = 0, c = nexttiled(clients); c; c = nexttiled(c->next)) {
+        if (c->mon != curmon) continue;
+        cx = curmon->wx + (i / rows) * cw;
+        cy = curmon->wy + (i % rows) * ch;
+        ah = ((i + 1) % rows == 0) ? curmon->wh - ch * rows : 0;
+        aw = (i >= rows * (cols - 1)) ? curmon->ww - cw * cols : 0;
+        resize(c, cx, cy, cw - 2 * c->bw + aw, ch - 2 * c->bw + ah);
+        i++;
+    }
+}
+
+void
+fibonacci(int s) {
+    unsigned int i, n, nx, ny, nw, nh;
+    Client* c;
+
+    for (n = 0, c = nexttiled(clients); c; c = nexttiled(c->next))
+        if (c->mon == curmon) n++;
+    if (n == 0) return;
+
+    nx = curmon->wx;
+    ny = curmon->wy;
+    nw = curmon->ww;
+    nh = curmon->wh;
+
+    for (i = 0, c = nexttiled(clients); c; c = nexttiled(c->next)) {
+        if (c->mon != curmon) continue;
+
+        if ((i % 2 && nh / 2 > 2 * c->bw)
+            || (!(i % 2) && nw / 2 > 2 * c->bw)) {
+            if (i < n - 1) {
+                if (i % 2) nh /= 2;
+                else nw /= 2;
+                if ((i % 4) == 2 && !s) nx += nw;
+                else if ((i % 4) == 3 && !s) ny += nh;
+            }
+            if ((i % 4) == 0) ny += s ? nh : -nh;
+            else if ((i % 4) == 1) nx += nw;
+            else if ((i % 4) == 2) ny += nh;
+            else if ((i % 4) == 3) nx += s ? nw : -nw;
+
+            if (i == 0) {
+                if (n != 1) nw = curmon->ww * mfact;
+                ny = curmon->wy;
+            }
+            else if (i == 1) {
+                nw = curmon->ww - nw;
+            }
+            i++;
+        }
+        resize(c, nx, ny, nw - 2 * c->bw, nh - 2 * c->bw);
+    }
+}
+
+void
+dwindle(void) {
+    fibonacci(1);
+}
+
+void
+spiral(void) {
+    fibonacci(0);
+}
+
 Client *
 nextchild(Client *p, Client *c) {
     for (; c && c->parent != p->hwnd; c = c->next);
